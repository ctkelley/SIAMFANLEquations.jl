<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ptcsol: Pseudo-Transient Continuation Solver · SIAMFANLEquations.jl</title><meta name="title" content="ptcsol: Pseudo-Transient Continuation Solver · SIAMFANLEquations.jl"/><meta property="og:title" content="ptcsol: Pseudo-Transient Continuation Solver · SIAMFANLEquations.jl"/><meta property="twitter:title" content="ptcsol: Pseudo-Transient Continuation Solver · SIAMFANLEquations.jl"/><meta name="description" content="Documentation for SIAMFANLEquations.jl."/><meta property="og:description" content="Documentation for SIAMFANLEquations.jl."/><meta property="twitter:description" content="Documentation for SIAMFANLEquations.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SIAMFANLEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SIAMFANLEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../nsol/">nsol: systems of equations with direct linear solvers</a></li><li class="is-active"><a class="tocitem" href>ptcsol: Pseudo-Transient Continuation Solver</a></li><li><a class="tocitem" href="../nsoli/">nsoli: systems of equations with Krylov linear solvers</a></li><li><a class="tocitem" href="../ptcsoli/">ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a></li><li><a class="tocitem" href="../aasol/">aasol: solve fixed point prolbems with Anderson acceleration</a></li></ul></li><li><span class="tocitem">Scalar Equations</span><ul><li><a class="tocitem" href="../nsolsc/">nsolsc: scalar equation solver</a></li><li><a class="tocitem" href="../ptcsolsc/">ptcsolsc: pseudo-transient continuation</a></li><li><a class="tocitem" href="../secant/">secant: scalar equation solver</a></li></ul></li><li><span class="tocitem">Linear Solvers</span><ul><li><a class="tocitem" href="../kl_gmres/">kl_gmres: GMRES linear solver</a></li><li><a class="tocitem" href="../kl_bicgstab/">kl_bigstab: BiCGSTAB linear solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>ptcsol: Pseudo-Transient Continuation Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ptcsol: Pseudo-Transient Continuation Solver</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ctkelley/SIAMFANLEquations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/master/docs/src/functions/ptcsol.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ptcsol:-Pseudo-Transient-Continuation-Solver"><a class="docs-heading-anchor" href="#ptcsol:-Pseudo-Transient-Continuation-Solver">ptcsol: Pseudo-Transient Continuation Solver</a><a id="ptcsol:-Pseudo-Transient-Continuation-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#ptcsol:-Pseudo-Transient-Continuation-Solver" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIAMFANLEquations.ptcsol-NTuple{5, Any}" href="#SIAMFANLEquations.ptcsol-NTuple{5, Any}"><code>SIAMFANLEquations.ptcsol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ptcsol(F!, x0, FS, FPS, J! = diffjac!; rtol=1.e-6, atol=1.e-12,              maxit=20, delta0=1.e-6, dx=1.e-7, pdata = nothing, jfact = klfact,                printerr = true, keepsolhist = false, jknowsdt = false)</p><p>C. T. Kelley, 2022</p><p>Julia versions of the nonlinear solvers from my SIAM books.  Herewith: some new stuff ==&gt; ptcsol</p><p>PTC finds the steady-state solution of u&#39; = -F(u), u(0) = u_0. The - sign is a convention.</p><p>You must allocate storage for the function and Jacobian in advance –&gt; in the calling program &lt;– ie. in FS and FPS</p><p>Inputs:</p><ul><li><p>F!: function evaluation, the ! indicates that F! overwrites FS, your   preallocated storage for the function.</p><p>So, FS=F!(FS,x) or FS=F!(FS,x,pdata) returns FS=F(x)</p><p>Your function MUST have –&gt; return FS &lt;– at the end.   See the examples in the TestProblems/Systems/FBeam!.jl</p></li><li><p>x0: initial iterate</p></li></ul><ul><li><p>FS: Preallocated storage for function. It is a vector of size N</p><p>You should store it as (N) and design F! to use vectors of size (N). If you use (N,1) consistently instead, the solvers may work, but I make no guarantees.</p></li><li><p>FPS: preallocated storage for Jacobian. It is an N x N matrix</p><p>If FPS is sparse, you <strong>must</strong> allocate storage for the diagonal so I will have room to put 1/dt in there.</p></li><li><p>J!: Jacobian evaluation, the ! indicates that J! overwrites FPS, your   preallocated storage for the Jacobian. If you leave this out the   default is a finite difference Jacobian.</p><p>So, FP=J!(FP,FS,x) or FP=J!(FP,FS,x,pdata) returns FP=F&#39;(x);   (FP,FS, x) must be the argument list, even if FP does not need FS.   One reason for this is that the finite-difference Jacobian   does and that is the default in the solver.</p><p>Your Jacobian function MUST have –&gt; return FP &lt;– at the end.    See the examples in the TestProblems/Systems/FBeam!.jl</p><p>You may have a better way to add (1/dt) I to your Jacobian. If you   want to do this yourself then your Jacobian function should be   FP=J!(FP,FS,x,dt) or FP=J!(FP,FS,x,dt,pdata) and return   F&#39;(x) + (1.0/dt)*I. </p><p>You will also have to set the kwarg <strong>jknowsdt</strong> to true.</p></li><li><p>Precision: Lemme tell ya &#39;bout precision. I designed this code for    full precision   functions and linear algebra in any precision you want. You can declare   FPS as Float64, Float32, or Float16 and ptcsol will do the right thing if   YOU do not destroy the declaration in your J! function. I&#39;m amazed   that this works so easily. If the Jacobian is reasonably well   conditioned, you can cut the cost of Jacobian factorization and   storage in half with no loss. For large dense Jacobians and inexpensive   functions, this is a good deal.</p><p>BUT ... There is very limited support for direct sparse solvers in   anything other than Float64. I recommend that you only use Float64   with direct sparse solvers unless you really know what you&#39;re doing. I   have a couple examples in the notebook, but watch out.</p></li></ul><hr/><p>Keyword Arguments (kwargs):</p><p>rtol and atol: relative and absolute error tolerances</p><p>delta0: initial pseudo time step. The default value of 1.e-3 is a bit conservative and is one option you really should play with. Look at the example where I set it to 1.0!</p><p>maxit: limit on nonlinear iterations, default=100. </p><p>This is coupled to delta0. If your choice of delta0 is too small (conservative) then you&#39;ll need many iterations to converge and will need a larger value of maxit</p><p>For PTC you&#39;ll need more iterations than for a straight-up nonlinear solve. This is part of the price for finding the  stable solution.</p><p>dx: default = 1.e-7</p><p>difference increment in finite-difference derivatives       h=dx*norm(x)+1.e-6</p><p>pdata:</p><p>precomputed data for the function/Jacobian.  Things will go better if you use this rather than hide the data  in global variables within the module for your function/Jacobian</p><p>jfact: default = klfact (tries to figure out best choice) </p><p>If your Jacobian has any special structure, please set jfact to the correct choice for a factorization.</p><p>I use jfact when I call PTCUpdate to evaluate the Jacobian (using your J!) and factor it. The default is to use klfact (an internal function) to do something reasonable. For general dense matrices, klfact picks lu! to compute an LU factorization and share storage with the Jacobian.  You may change LU to something else by, for example, setting jfact = cholseky! if your Jacobian is spd.</p><p>klfact knows about banded matrices and picks qr. You should, however RTFM, allocate the extra two upper bands, and use jfact=qr! to override klfact.</p><p>klfact uses lu for general sparse matrices.</p><p>If you give me something that klfact does not know how to dispatch on, then nothing happens. I just return the original Jacobian matrix and  ptcsol will use backslash to compute the Newton step.</p><p>I know that this is probably not optimal in your situation, so it is  good to pick something else, like jfact = lu.</p><p>printerr: default = true</p><p>I print a helpful message when the solver fails. To suppress that message set printerr to false.</p><p>keepsolhist: default = false</p><p>Set this to true to get the history of the iteration in the output tuple. This is on by default for scalar equations and off for systems. Only turn it on if you have use for the data, which can get REALLY LARGE.</p><p>jknowsdt: default = false</p><p>Set this to true if your Jacobian evaluation function returns F&#39;(x) + (1/dt) I. You&#39;ll also need to follow the rules above for the Jacobian evaluation function. I do not recommend this and if your Jacobian is anything other than a matrix I can&#39;t promise anything. I&#39;ve tested this for matrix outputs only.</p><p>Output:</p><p>A named tuple (solution, functionval, history, stats, idid,                errcode, solhist) where</p><p>solution = converged result functionval = F(solution) history = the vector of residual norms (||F(x)||) for the iteration</p><p>Unlike nsol, nsoli, or even ptcsoli, ptcsol has a fixed cost per  iteration of one function, one Jacobian, and one Factorization. Hence iteration statistics are not interesting and not in the output. </p><p>idid=true if the iteration succeeded and false if not.</p><p>errcode = 0 if the iteration succeeded         = -1 if the initial iterate satisfies the termination criteria         = 10 if no convergence after maxit iterations</p><p>solhist:</p><p>This is the entire history of the iteration if you&#39;ve set keepsolhist=true</p><p>solhist is an N x K array where N is the length of x and K is the number of iteration + 1. So, for scalar equations, it&#39;s a row vector.</p><p><strong>Example for ptcsol</strong></p><p><strong>The buckling beam problem.</strong></p><p>You&#39;ll need to use TestProblems for this to work.</p><pre><code class="language-julia-repl hljs">julia&gt; using SIAMFANLEquations.TestProblems

julia&gt; n=63; maxit=1000; delta = 0.01; lambda = 20.0;

julia&gt; bdata = beaminit(n, 0.0, lambda); x = bdata.x;

julia&gt; u0 = x .* (1.0 .- x) .* (2.0 .- x);

julia&gt; u0 .*= exp.(-10.0 * u0);

julia&gt; FS = copy(u0); FPS = copy(bdata.D2);

julia&gt; pout = ptcsol( FBeam!, u0, FS, FPS, BeamJ!; 
 rtol = 1.e-10, pdata = bdata, delta0 = delta, maxit = maxit);

julia&gt; # It takes a few iterations to get there.
       length(pout.history)
25

julia&gt; [pout.history[1:5] pout.history[21:25]]
5×2 Array{Float64,2}:
 6.31230e+01  9.75412e-01
 7.52624e+00  8.35295e-02
 8.31545e+00  6.58797e-04
 3.15455e+01  4.12697e-08
 3.66566e+01  6.29295e-12

julia&gt; # We get the nonnegative steady state.
       maximum(pout.solution)
2.19086e+00</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/706ff0392f724a87fceb404b797f9dc392531f7a/src/Solvers/ptcsol.jl#L1-L223">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nsol/">« nsol: systems of equations with direct linear solvers</a><a class="docs-footer-nextpage" href="../nsoli/">nsoli: systems of equations with Krylov linear solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 15 March 2024 09:16">Friday 15 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
