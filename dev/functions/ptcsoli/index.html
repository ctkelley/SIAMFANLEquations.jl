<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver · SIAMFANLEquations.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SIAMFANLEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SIAMFANLEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../nsol/">nsol: systems of equations with direct linear solvers</a></li><li><a class="tocitem" href="../ptcsol/">ptcsol: Pseudo-Transient Continuation Solver</a></li><li><a class="tocitem" href="../nsoli/">nsoli: systems of equations with Krylov linear solvers</a></li><li class="is-active"><a class="tocitem" href>ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a></li><li><a class="tocitem" href="../aasol/">aasol: solve fixed point prolbems with Anderson acceleration</a></li></ul></li><li><span class="tocitem">Scalar Equations</span><ul><li><a class="tocitem" href="../nsolsc/">nsolsc: scalar equation solver</a></li><li><a class="tocitem" href="../ptcsolsc/">ptcsolsc: pseudo-transient continuation</a></li><li><a class="tocitem" href="../secant/">secant: scalar equation solver</a></li></ul></li><li><span class="tocitem">Linear Solvers</span><ul><li><a class="tocitem" href="../kl_gmres/">kl_gmres: GMRES linear solver</a></li><li><a class="tocitem" href="../kl_bicgstab/">kl_bigstab: BiCGSTAB linear solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/master/docs/src/functions/ptcsoli.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ptcsoli:-Pseudo-Transient-Continuation-Newton-Krylov-Solver"><a class="docs-heading-anchor" href="#ptcsoli:-Pseudo-Transient-Continuation-Newton-Krylov-Solver">ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a><a id="ptcsoli:-Pseudo-Transient-Continuation-Newton-Krylov-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#ptcsoli:-Pseudo-Transient-Continuation-Newton-Krylov-Solver" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SIAMFANLEquations.ptcsoli" href="#SIAMFANLEquations.ptcsoli"><code>SIAMFANLEquations.ptcsoli</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function ptcsoli(     F!,     x0,     FS,     FPS,     Jvec = dirder;     rtol = 1.e-6,     atol = 1.e-12,     maxit = 20,     lmaxit = -1,     lsolver = &quot;gmres&quot;,     eta = 0.1,     fixedeta = true,     Pvec = nothing,     PvecKnowsdelta = false,      pside = &quot;right&quot;,     delta0 = 1.e-6,     dx = 1.e-7,     pdata = nothing,     printerr = true,     keepsolhist = false, )</p><p>C. T. Kelley, 2021</p><p>Julia versions of the nonlinear solvers from my SIAM books.  Herewith: some new stuff ==&gt; ptcsoli</p><p>PTC finds the steady-state solution of u&#39; = -F(u), u(0) = u_0. The - sign is a convention.</p><p>You must allocate storage for the function and Krylov basis in advance –&gt; in the calling program &lt;– ie. in FS and FPS</p><p>Inputs:</p><ul><li><p>F!: function evaluation, the ! indicates that F! overwrites FS, your   preallocated storage for the function.</p><p>So, FV=F!(FV,x) or FV=F!(FV,x,pdata) returns FV=F(x)</p></li><li><p>x0: initial iterate</p></li></ul><ul><li>FS: Preallocated storage for function. It is an N x 1 column vector.</li></ul><p>You may dimension it as (n,) or (n,1). (n,) is best, but the solvers can deal with it either way.</p><ul><li>FPS: preallocated storage for the Krylov basis. It is an N x m matrix where      you plan to take at most m-1 GMRES iterations before a restart. </li></ul><ul><li><p>Jvec: Jacobian vector product, If you leave this out the   default is a finite difference directional derivative.</p><p>So, FP=Jvec(v,FS,x) or FP=Jvec(v,FS,x,pdata) returns FP=F&#39;(x) v. </p><p>(v, FS, x) or (v, FS, x, pdata) must be the argument list,   even if FP does not need FS.   One reason for this is that the finite-difference derivative   does and that is the default in the solver.</p></li><li><p>Precision: Lemme tell ya &#39;bout precision. I designed this code for    full precision functions and linear algebra in any precision you want.    You can declare FPS as Float64 or Float32 and ptcsoli    will do the right thing. Float16 support is there, but not working well.</p><p>If the Jacobian is reasonably well conditioned, you can cut the cost   of orthogonalization and storage (for GMRES) in half with no loss.   There is no benefit if your linear solver is not GMRES or if   othogonalization and storage of the Krylov vectors is only a   small part of the cost of the computation. So if your preconditioner   is good and you only need a few Krylovs/Newton, reduced precision won&#39;t   help you much.</p><p>BiCGSTAB does not benefit from reduced precsion.</p></li></ul><hr/><p>Keyword Arguments (kwargs):</p><p>rtol and atol: relative and absolute error tolerances</p><p>delta0: initial pseudo time step. The default value of 1.e-3 is a bit conservative and is one option you really should play with. Look at the example where I set it to 1.0!</p><p>maxit: limit on nonlinear iterations, default=100. </p><p>This is coupled to delta0. If your choice of delta0 is too small (conservative) then you&#39;ll need many iterations to converge and will need a larger value of maxit</p><p>For PTC you&#39;ll need more iterations than for a straight-up nonlinear solve. This is part of the price for finding the  stable solution. </p><p>lmaxit: limit on linear iterations. If lmaxit &gt; m-1, where FPS has m columns, and you need more than m-1 linear iterations, then GMRES will restart.</p><p>The default is -1. For GMRES this means that you&#39;ll take m-1 iterations, where size(V) = (n,m), and get no restarts. For BiCGSTAB you&#39;ll then get the default of 10 iterations.</p><p>lsolver: the linear solver, default = &quot;gmres&quot;</p><p>Your choices will be &quot;gmres&quot; or &quot;bicgstab&quot;. However, gmres is the only option for now. </p><p>eta and fixed eta: eta &gt; 0 or there&#39;s an error.</p><p>The linear solver terminates when ||F&#39;(x)s + F(x) || &lt;= etag || F(x) ||</p><p>where</p><p>etag = eta if fixedeta=true</p><p>etag = Eisenstat-Walker as implemented in book if fixedeta=false</p><p>The default, which may change, is eta=.1, fixedeta=true </p><p>Pvec: Preconditioner-vector product. The rules are similar to Jvec     So, Pv=Pvec(v,x) or Pv=Pvec(v,x,pdata) returns P(x) v where     P(x) is the preconditioner. You must use x as an input even     if your preconditioner does not depend on x.</p><p>PvecKnowsdelta: If you want your preconditioner-vector product to depend on      the pseudo-timestep delta, put an array deltaval in your precomputed     data. Initialize it as     deltaval = zeros(1,)     and let ptcsoli know about it by setting the kwarg     PvecKnowsdelta = true     ptcsoli will update the value in deltaval with every change     to delta with pdata.deltaval[1]=delta     so your preconditioner-vector product can get to it.</p><p>pside: apply preconditioner on pside, default = &quot;right&quot;. I do not       recommend &quot;left&quot;. The problem with &quot;left&quot; for ptcsoli is       that it can fail to satisfy the inexact Newton condition for        the unpreconditioned equation, especially early in the iteration       and lead to an incorrect result (unstable solution or wrong        branch of steady state).       See Chapter 3 for the story on this. </p><p>dx: default = 1.e-7</p><p>difference increment in finite-difference derivatives       h=dx*norm(x)+1.e-8 </p><p>pdata:</p><p>precomputed data for the function/Jacobian-vector/Preconditioner-vector products.  Things will go better if you use this rather than hide the data in global variables within the module for your function/Jacobian</p><p>If you use pdata in any of F!, Jvec, or Pvec, you must use in in all of them. precomputed data for the function/Jacobian.  Things will go better if you use this rather than hide the data  in global variables within the module for your function/Jacobian. </p><p>printerr: default = true</p><p>I print a helpful message when the solver fails. To suppress that message set printerr to false. </p><p>keepsolhist: default = false</p><p>Set this to true to get the history of the iteration in the output tuple. This is on by default for scalar equations and off for systems. Only turn it on if you have use for the data, which can get REALLY LARGE.</p><p>Output:</p><p>A named tuple (solution, functionval, history, stats, idid,                errcode, solhist) where</p><p>solution = converged result functionval = F(solution) history = the vector of residual norms (||F(x)||) for the iteration stats = named tuple of the history of (ifun, ijac, ikfail), the number of functions/jacobian-vector prodcuts/linear solver filures at each iteration.</p><p>I do not count the function values for a finite-difference derivative because they count toward a Jacobian-vector product.</p><p>Linear solver failures need not cause the nonlinear iteration to fail.  You get a warning and that is all. </p><p>idid=true if the iteration succeeded and false if not. </p><p>errcode = 0 if if the iteration succeeded </p><pre><code class="nohighlight hljs">    = -1 if the initial iterate satisfies the termination criteria
    = 10 if no convergence after maxit iterations</code></pre><p>solhist:</p><p>This is the entire history of the iteration if you&#39;ve set keepsolhist=true</p><p>solhist is an N x K array where N is the length of x and K is the number of iteration + 1. So, for scalar equations, it&#39;s a row vector.</p><p><strong>Example from the docstrings for ptcsol</strong></p><p><strong>The buckling beam problem.</strong></p><p>You&#39;ll need to use TestProblems for this to work. The preconditioner is a solver for the high order term.</p><pre><code class="language-julia-repl hljs">julia&gt; using SIAMFANLEquations.TestProblems

julia&gt; function PreCondBeam(v, x, bdata)
          J = bdata.D2
          ptv = J
       end
PreCondBeam (generic function with 1 method)

julia&gt; n=63; maxit=1000; delta0 = 0.01; lambda = 20.0;

julia&gt; bdata = beaminit(n, 0.0, lambda);

julia&gt; x = bdata.x; u0 = x .* (1.0 .- x) .* (2.0 .- x); u0 .*= exp.(-10.0 * u0);


julia&gt; FS = copy(u0); FPJV=zeros(n,20);

julia&gt; pout = ptcsoli( FBeam!, u0, FS, FPJV; delta0 = delta0, pdata = bdata,
       eta = 1.e-2, rtol = 1.e-10, maxit = maxit, Pvec = PreCondBeam);

julia&gt; # It takes a few iterations to get there.
       length(pout.history)
25

julia&gt; [pout.history[1:5] pout.history[21:25]]
5×2 Array{Float64,2}:
 6.31230e+01  1.79578e+00
 7.45926e+00  2.65964e-01
 8.73598e+00  6.58278e-03
 2.91936e+01  8.35069e-06
 3.47969e+01  5.11594e-09

julia&gt; # We get the nonnegative stedy state.
       norm(pout.solution,Inf)
2.19086e+00

n=63; maxit=1000; delta0 = 0.01; lambda = 20.0;

julia&gt; # Use BiCGSTAB for the linear solver

julia&gt; FS = copy(u0); FPJV=zeros(n,);

julia&gt; pout = ptcsoli( FBeam!, u0, FS, FPJV; delta0 = delta0, pdata = bdata,
       eta = 1.e-2, rtol = 1.e-10, maxit = maxit, 
       Pvec = PreCondBeam, lsolver=&quot;bicgstab&quot;);

julia&gt; # Same number of iterations as GMRES, but each one costs double 

julia&gt; # the Jacobian-vector products and much less storage

julia&gt; length(pout.history)
25

julia&gt; [pout.history[1:5] pout.history[21:25]]
5×2 Matrix{Float64}:
 6.31230e+01  1.68032e+00
 7.47081e+00  2.35073e-01
 8.62095e+00  5.18262e-03
 2.96495e+01  3.23715e-06
 3.51504e+01  3.33107e-10
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/676f1eaee3d07ebf6afa15f008aae7d2d814c513/src/Solvers/ptcsoli.jl#L1-L295">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nsoli/">« nsoli: systems of equations with Krylov linear solvers</a><a class="docs-footer-nextpage" href="../aasol/">aasol: solve fixed point prolbems with Anderson acceleration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Sunday 3 October 2021 18:29">Sunday 3 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
