<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>nsoli: systems of equations with Krylov linear solvers · SIAMFANLEquations.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SIAMFANLEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SIAMFANLEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../nsol/">nsol: systems of equations with direct linear solvers</a></li><li><a class="tocitem" href="../ptcsol/">ptcsol: Pseudo-Transient Continuation Solver</a></li><li class="is-active"><a class="tocitem" href>nsoli: systems of equations with Krylov linear solvers</a></li><li><a class="tocitem" href="../ptcsoli/">ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a></li><li><a class="tocitem" href="../aasol/">aasol: solve fixed point prolbems with Anderson acceleration</a></li></ul></li><li><span class="tocitem">Scalar Equations</span><ul><li><a class="tocitem" href="../nsolsc/">nsolsc: scalar equation solver</a></li><li><a class="tocitem" href="../ptcsolsc/">ptcsolsc: pseudo-transient continuation</a></li><li><a class="tocitem" href="../secant/">secant: scalar equation solver</a></li></ul></li><li><span class="tocitem">Linear Solvers</span><ul><li><a class="tocitem" href="../kl_gmres/">kl_gmres: GMRES linear solver</a></li><li><a class="tocitem" href="../kl_bicgstab/">kl_bigstab: BiCGSTAB linear solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>nsoli: systems of equations with Krylov linear solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>nsoli: systems of equations with Krylov linear solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/master/docs/src/functions/nsoli.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="nsoli:-systems-of-equations-with-Krylov-linear-solvers"><a class="docs-heading-anchor" href="#nsoli:-systems-of-equations-with-Krylov-linear-solvers">nsoli: systems of equations with Krylov linear solvers</a><a id="nsoli:-systems-of-equations-with-Krylov-linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#nsoli:-systems-of-equations-with-Krylov-linear-solvers" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SIAMFANLEquations.nsoli" href="#SIAMFANLEquations.nsoli"><code>SIAMFANLEquations.nsoli</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nsoli(F!, x0, FS, FPS, Jvec=dirder; rtol=1.e-6, atol=1.e-12,
           maxit=20, lmaxit=-1, lsolver=&quot;gmres&quot;, eta=.1,
           fixedeta=true, Pvec=nothing, pside=&quot;right&quot;,
           armmax=10, dx = 1.e-7, armfix=false, pdata = nothing,
           printerr = true, keepsolhist = false, 
           Krylov_Data = nothing, stagnationok=false)</code></pre><p>)</p><p>C. T. Kelley, 2022</p><p>Julia versions of the nonlinear solvers from my SIAM books.  Herewith: nsoli</p><p>You must allocate storage for the function and the Krylov basis in advance –&gt; in the calling program &lt;– ie. in FS and FPS</p><p>Inputs:</p><ul><li><p>F!: function evaluation, the ! indicates that F! overwrites FS, your   preallocated storage for the function.</p><p>So FS=F!(FS,x) or FS=F!(FS,x,pdata) returns FS=F(x)</p><p>Your function MUST have –&gt; return FS &lt;– at the end.   See the examples in the docstrings</p></li></ul><ul><li>x0: initial iterate</li></ul><ul><li><p>FS: Preallocated storage for function. It is a vector of size N</p><p>You should store it as (N) and design F! to use vectors of size (N). If you use (N,1) consistently instead, the solvers may work, but I make no guarantees.</p></li><li><p>FPS: preallocated storage for the Krylov basis. It is an N x m matrix where      you plan to take at most m-1 GMRES iterations before a restart. </p></li></ul><ul><li><p>Jvec: Jacobian vector product, If you leave this out the   default is a finite difference directional derivative.</p><p>So, FP=Jvec(v,FS,x) or FP=Jvec(v,FS,x,pdata) returns FP=F&#39;(x) v. </p><p>(v, FS, x) or (v, FS, x, pdata) must be the argument list,    even if FP does not need FS.   One reason for this is that the finite-difference derivative   does and that is the default in the solver.</p></li><li><p>Precision: Lemme tell ya &#39;bout precision. I designed this code for    full precision functions and linear algebra in any precision you want.    You can declare FPS as Float64 or Float32 and nsoli    will do the right thing. Float16 support is there, but not working well.</p><p>If the Jacobian is reasonably well conditioned, you can cut the cost   of orthogonalization and storage (for GMRES) in half with no loss.    There is no benefit if your linear solver is not GMRES or if    orthogonalization and storage of the Krylov vectors is only a   small part of the cost of the computation. So if your preconditioner   is good and you only need a few Krylovs/Newton, reduced precision won&#39;t   help you much.</p><p>BiCGSTAB does not benefit from reduced precision. </p></li></ul><hr/><p>Keyword Arguments (kwargs):</p><p>rtol and atol: relative and absolute error tolerances</p><p>maxit: limit on nonlinear iterations</p><p>lmaxit: limit on linear iterations. If lmaxit &gt; m-1, where FPS has m columns, and you need more than m-1 linear iterations, then GMRES  will restart. </p><p>The default is -1 for GMRES. This means that you&#39;ll take m-1 iterations,  where size(V) = (n,m), and get no restarts. For BiCGSTAB the default is 10.</p><p>lsolver: the linear solver, default = &quot;gmres&quot;</p><p>Your choices will be &quot;gmres&quot; or &quot;bicgstab&quot;. However, gmres is the only option for now.</p><p>eta and fixed eta: eta &gt; 0 or there&#39;s an error</p><p>The linear solver terminates when ||F&#39;(x)s + F(x) || &lt;= etag || F(x) ||</p><p>where </p><p>etag = eta if fixedeta=true</p><p>etag = Eisenstat-Walker as implemented in book if fixedeta=false</p><p>The default, which may change, is eta=.1, fixedeta=true</p><p>Pvec: Preconditioner-vector product. The rules are similar to Jvec     So, Pv=Pvec(v,x) or Pv=Pvec(v,x,pdata) returns P(x) v where     P(x) is the preconditioner. You must use x as an input even     if your preconditioner does not depend on x</p><p>pside: apply preconditioner on pside, default = &quot;right&quot;. I do not       recommend &quot;left&quot;. See Chapter 3 for the story on this.</p><p>armmax: upper bound on step size reductions in line search</p><p>dx: default = 1.e-7</p><p>difference increment in finite-difference derivatives       h=dx*norm(x,Inf)+1.e-8</p><p>armfix: default = false</p><p>The default is a parabolic line search (ie false). Set to true and the step size will be fixed at .5. Don&#39;t do this unless you are doing experiments for research.</p><p>pdata:</p><p>precomputed data for the function, Jacobian-vector, and Preconditioner-vector products.  Things will go better if you use this rather than hide the data  in global variables within the module for your function/Jacobian</p><p>If you use pdata in any of F!, Jvec, or Pvec, you must use in in all of them.</p><p>printerr: default = true</p><p>I print a helpful message when the solver fails. To suppress that message set printerr to false.</p><p>keepsolhist: default = false</p><p>Set this to true to get the history of the iteration in the output tuple. This is on by default for scalar equations and off for systems. Only turn it on if you have use for the data, which can get REALLY LARGE.</p><p>Krylov_Data: default = nothing</p><p>This is a structure where I put the internal storage for the solvers. You can (but probably should not) preallocate this your self with the nkl_init function.</p><p>Krylov_Data </p><p>= nkl_init(n,lsolver)</p><p>This is a dangerous thing to mess with and I only recommend it if  the allocations in nsoli become a problem in continuation or IVP integration. Krylov_Data is where I store the solution at the end of the iteration and if you reuse it without copying the solution to somewhere else, you&#39;ll lose it and it will be overwritten with the new solution. The continuation case study uses this and you  should look at that to see what I did.</p><p>stagnationok: default = false</p><p>Set this to true if you want to disable the line search and either observe divergence or stagnation. This is only useful for research or writing a book.</p><p>Output:</p><ul><li>A named tuple (solution, functionval, history, stats, idid,              errcode, solhist)</li></ul><p>where</p><p>– solution = converged result</p><p>– functionval = F(solution)</p><p>– history = the vector of residual norms (||F(x)||) for the iteration</p><p>– stats = named tuple of the history of (ifun, ijac, iarm, ikfail), the  number of functions/Jacobian-vector prods/steplength reductions/linear solver failures at each iteration. Linear solver failures DO NOT mean that the nonlinear solver will fail. You should look at this stat if, for example, the line search fails. Increasing the size of FPS and/or lmaxit might solve the problem.</p><p>I do not count the function values for a finite-difference derivative because they count toward a Jacobian-vector product.</p><p>– idid=true if the iteration succeeded and false if not.</p><p>– errcode = 0 if the iteration succeeded</p><pre><code class="nohighlight hljs">    = -1 if the initial iterate satisfies the termination criteria

    = 10 if no convergence after maxit iterations

    = 1  if the line search failed</code></pre><p>– solhist:</p><pre><code class="nohighlight hljs">  This is the entire history of the iteration if you&#39;ve set
  keepsolhist=true</code></pre><p>solhist is an N x K array where N is the length of x and K is the number of iteration + 1. So, for scalar equations, it&#39;s a row vector.</p><hr/><p><strong>Example for nsoli</strong></p><p><strong>Simple 2D problem.</strong></p><p>You should get the same results as for nsol.jl because GMRES will solve the equation for the step exactly in two iterations. Finite difference Jacobians and analytic Jacobian-vector products for full precision and finite difference Jacobian-vector products for single precision.</p><p>BiCGSTAB converges in 5 iterations and each nonlinear iteration costs two Jacobian-vector products. Note that the storage for the Krylov space in GMRES (jvs) is replace by a single vector (fpv) when BiCGSTAB is the linear solver.</p><pre><code class="language-julia-repl hljs">julia&gt; function f!(fv,x)
       fv[1]=x[1] + sin(x[2])
       fv[2]=cos(x[1]+x[2])
       return fv
       end
f! (generic function with 1 method)

julia&gt; function JVec(v, fv, x)
       jvec=zeros(2);
       p=-sin(x[1]+x[2])
       jvec[1]=v[1]+cos(x[2])*v[2]
       jvec[2]=p*(v[1]+v[2])
       return jvec
       end
JVec (generic function with 1 method)

julia&gt; x0=ones(2); fv=zeros(2); jv=zeros(2,2); 

julia&gt; jv32=zeros(Float32,2,2);

julia&gt; jvs=zeros(2,3); jvs32=zeros(Float32,2,3);

julia&gt; nout=nsol(f!,x0,fv,jv; sham=1);

julia&gt; kout=nsoli(f!,x0,fv,jvs,JVec; 
                  fixedeta=true, eta=.1, lmaxit=2);

julia&gt; kout32=nsoli(f!,x0,fv,jvs32; 
                    fixedeta=true, eta=.1, lmaxit=2);

julia&gt; [nout.history kout.history kout32.history]
5×3 Array{Float64,2}:
 1.88791e+00  1.88791e+00  1.88791e+00
 2.43119e-01  2.43120e-01  2.43119e-01
 1.19231e-02  1.19231e-02  1.19230e-02
 1.03266e-05  1.03261e-05  1.03264e-05
 1.46388e-11  1.40862e-11  1.39825e-11

julia&gt; fpv=zeros(2);

julia&gt; koutb=nsoli(f!,x0,fv,fpv,JVec; 
            fixedeta=true, eta=.1, lmaxit=2, lsolver=&quot;bicgstab&quot;);

julia&gt; koutb.history
6-element Vector{Float64}:
 1.88791e+00
 2.43120e-01
 1.19231e-02
 4.87500e-04
 7.54236e-06
 3.84646e-07</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/4647c6c811a076d17898f6611b797ee67bf6f845/src/Solvers/nsoli.jl#L1-L282">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ptcsol/">« ptcsol: Pseudo-Transient Continuation Solver</a><a class="docs-footer-nextpage" href="../ptcsoli/">ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Sunday 21 August 2022 14:49">Sunday 21 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
