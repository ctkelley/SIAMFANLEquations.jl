<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>nsolsc: scalar equation solver · SIAMFANLEquations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SIAMFANLEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">SIAMFANLEquations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../nsol/">nsol: systems of equations with direct linear solvers</a></li><li><a class="tocitem" href="../ptcsol/">ptcsol: Pseudo-Transient Continuation Solver</a></li><li><a class="tocitem" href="../nsoli/">nsoli: systems of equations with Krylov linear solvers</a></li><li><a class="tocitem" href="../ptcsoli/">ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a></li></ul></li><li><span class="tocitem">Scalar Equations</span><ul><li class="is-active"><a class="tocitem" href>nsolsc: scalar equation solver</a></li><li><a class="tocitem" href="../ptcsolsc/">ptcsolsc: pseudo-transient continuation</a></li><li><a class="tocitem" href="../secant/">secant: scalar equation solver</a></li></ul></li><li><span class="tocitem">Linear Solvers</span><ul><li><a class="tocitem" href="../kl_gmres/">kl_gmres: GMRES linear solver</a></li><li><a class="tocitem" href="../kl_bicgstab/">kl_bigstab: BiCGSTAB linear solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Scalar Equations</a></li><li class="is-active"><a href>nsolsc: scalar equation solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>nsolsc: scalar equation solver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/master/docs/src/functions/nsolsc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="nsolsc:-scalar-equation-solver"><a class="docs-heading-anchor" href="#nsolsc:-scalar-equation-solver">nsolsc: scalar equation solver</a><a id="nsolsc:-scalar-equation-solver-1"></a><a class="docs-heading-anchor-permalink" href="#nsolsc:-scalar-equation-solver" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SIAMFANLEquations.nsolsc-Tuple{Any,Any}" href="#SIAMFANLEquations.nsolsc-Tuple{Any,Any}"><code>SIAMFANLEquations.nsolsc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nsolsc(f,x0, fp=difffp; rtol=1.e-6, atol=1.e-12, maxit=10,         solver=&quot;newton&quot;, sham=1, armmax=10, resdec=.1, dx=1.e-7,         armfix=false, pdata=nothing,         printerr=true, keepsolhist=true, stagnationok=false)</p><p>C. T. Kelley, 2020</p><p>Newton&#39;s method for scalar equations. Has most of the features a code for systems of equations needs. This is a wrapper for a call to nsol.jl, the real code for systems. </p><p>Input:</p><p>f: function</p><p>x0: initial iterate</p><p>fp: derivative. If your derivative function is fp, you give me its name. For example fp=foobar tells me that foobar is your function for the derivative. The default is a forward difference Jacobian that I provide.</p><p>Keyword Arguments (kwargs):</p><p>rtol, atol: real and absolute error tolerances</p><p>maxit: upper bound on number of nonlinear iterations</p><p>solver:</p><p>Your choices are &quot;newton&quot;(default) or &quot;chord&quot;. However,  you have sham at your disposal only if you chose newton. &quot;chord&quot; will keep using the initial derivative until the iterate converges, uses the iteration budget, or the line search fails. It is not the same as sham=Inf, which is smarter.</p><p>If you use secant and your initial iterate is poor, you have made a mistake. I will help you by driving the line search with a finite difference derivative.</p><p>sham:</p><p>This is the Shamanskii method. If sham=1, you have Newton. The iteration updates the derivative every sham iterations. The convergence rate has local q-order sham+1 if you only count iterations where you update the derivative. You need not provide your own derivative function to use this option. sham=Inf is chord only if chord is converging well.</p><p>armmax: upper bound on stepsize reductions in linesearch</p><p>resdec: target value for residual reduction. </p><p>The default value is .1. In the old MATLAB codes it was .5. I only turn Shamanskii on if the residuals are decreasing rapidly, at least a factor of resdec, and the line search is quiescent. If you want to eliminate resdec from the method ( you don&#39;t ) then set resdec = 1.0 and you will never hear from it again.  </p><p>dx:</p><p>This is the increment for forward difference, default = 1.e-7. dx should be roughly the square root of the noise in the function.</p><p>armfix:</p><p>The default is a parabolic line search (ie false). Set to true and the stepsize will be fixed at .5. Don&#39;t do this unless you are doing experiments for research.</p><p>pdata:</p><p>precomputed data for the function/derivative. Things will go better if you use this rather than hide the data in global variables within the module for your function/derivative If you use this option your function and derivative must take pdata as a second argument. eg f(x,pdata) and fp(x,pdata)</p><p>printerr:</p><p>I print a helpful message when the solver fails. To supress that message set printerr to false.</p><p>keepsolhist:</p><p>Set this to true to get the history of the iteration in the output tuple. This is on by default for scalar equations and off for systems. Only turn it on if you have use for the data, which can get REALLY LARGE.</p><p>stagnationok:</p><p>Set this to true if you want to disable the line search and either observe divergence or stagnation. This is only useful for research or writing a book.</p><p>Output:</p><p>A named tuple (solution, functionval, history, stats, idid,                errcode, solhist) where</p><p>solution = converged result functionval = F(solution) history = the vector of residual norms (||F(x)||) for the iteration stats = named tuple of the history of (ifun, ijac, iarm), the number of functions/derivatives/steplength reductions at each iteration.</p><p>I do not count the function values for a finite-difference derivative because they count toward a Jacobian evaluation. I do count them for the secant method model.</p><p>idid=true if the iteration succeeded and false if not.</p><p>errcode = 0 if if the iteration succeeded         = -1 if the initial iterate satisifies the termination criteria         = 10 if no convergence after maxit iterations         = 1  if the line search failed</p><p>solhist:</p><p>This is the entire history of the iteration if you&#39;ve set keepsolhist=true</p><p>nsolsc builds solhist with a function from the Tools directory. For systems, solhist is an N x K array where N is the length of x and K  is the number of iteration + 1. So, for scalar equations (N=1), solhist is a row vector. Hence the use of solhist&#39; in the example below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nsolout=nsolsc(atan,1.0;maxit=5,atol=1.e-12,rtol=1.e-12);

julia&gt; nsolout.history
6-element Array{Float64,1}:
 7.85398e-01
 5.18669e-01
 1.16332e-01
 1.06102e-03
 7.96200e-10
 2.79173e-24</code></pre><p><strong>If you have an analytic derivative, I will use it.</strong></p><pre><code class="language-julia-repl">julia&gt; fs(x)=x^2-4.0; fsp(x)=2x;

julia&gt; nsolout=nsolsc(fs,1.0,fsp; maxit=5,atol=1.e-9,rtol=1.e-9);

julia&gt; [nsolout.solhist&#39;.-2 nsolout.history]
6×2 Array{Float64,2}:
 -1.00000e+00  3.00000e+00
  5.00000e-01  2.25000e+00
  5.00000e-02  2.02500e-01
  6.09756e-04  2.43940e-03
  9.29223e-08  3.71689e-07
  2.22045e-15  8.88178e-15
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctkelley/SIAMFANLEquations.jl/blob/960ceba10a5644bdf85b14268ed4e057c22753e5/src/Solvers/Chapter1/nsolsc.jl#L1-L170">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ptcsoli/">« ptcsoli: Pseudo-Transient Continuation Newton-Krylov Solver</a><a class="docs-footer-nextpage" href="../ptcsolsc/">ptcsolsc: pseudo-transient continuation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 14 May 2021 19:23">Friday 14 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
